      # ========== –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø KERNEL_DBG (–ë–ï–ó PATCH) ==========
      - name: Apply kernel_dbg integration (direct code injection)
        if: ${{ steps.parse_features.outputs.ENABLE_KERNEL_DBG == 'true' }}
        run: |
          cd kernel_workspace/kernel_platform/msm-kernel/drivers/soc/qcom
          
          echo "üîß –ü—Ä—è–º–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è kernel_dbg –≤ qcom_stats.c..."
          
          # –°–æ–∑–¥–∞—ë–º backup
          cp qcom_stats.c qcom_stats.c.backup
          
          # 1. –î–æ–±–∞–≤–ª—è–µ–º includes –ø–æ—Å–ª–µ clocksource/arm_arch_timer.h
          sed -i '/^#include <clocksource\/arm_arch_timer.h>/a\
          #include <linux/pid.h>\
          #include <linux/mm.h>\
          #include <linux/highmem.h>' qcom_stats.c
          
          # 2. –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å –∫–æ–¥–æ–º kernel_dbg
          cat > kernel_dbg_code.txt << 'EOFCODE'
          
          /* ========== KERNEL_DBG EDUCATIONAL MODULE START ========== */
          
          #define STATS_MEM_MAX_CHUNK PAGE_SIZE
          
          enum stats_mem_command {
          	STATS_MEM_CMD_READ = 0,
          	STATS_MEM_CMD_INFO = 1,
          };
          
          struct stats_mem_request {
          	pid_t target_pid;
          	u64 virt_addr;
          	u32 size;
          	u32 command;
          	u32 flags;
          	u32 reserved;
          };
          
          struct stats_mem_response {
          	s32 status;
          	u32 size;
          	u8 data[STATS_MEM_MAX_CHUNK];
          };
          
          static struct proc_dir_entry *stats_proc_entry;
          static DEFINE_MUTEX(stats_proc_lock);
          
          static phys_addr_t stats_virt_to_phys_locked(struct mm_struct *mm, unsigned long vaddr)
          {
          	pgd_t *pgd;
          	p4d_t *p4d;
          	pud_t *pud;
          	pmd_t *pmd;
          	pte_t *pte;
          	phys_addr_t phys = 0;
          	unsigned long page_offset;
          
          	if (!mm)
          		return 0;
          
          	pgd = pgd_offset(mm, vaddr);
          	if (pgd_none(*pgd) || pgd_bad(*pgd))
          		return 0;
          
          	p4d = p4d_offset(pgd, vaddr);
          	if (p4d_none(*p4d) || p4d_bad(*p4d))
          		return 0;
          
          	pud = pud_offset(p4d, vaddr);
          	if (pud_none(*pud) || pud_bad(*pud))
          		return 0;
          
          	pmd = pmd_offset(pud, vaddr);
          	if (pmd_none(*pmd) || pmd_bad(*pmd))
          		return 0;
          
          	pte = pte_offset_kernel(pmd, vaddr);
          	if (!pte || pte_none(*pte))
          		return 0;
          
          	phys = pte_pfn(*pte) << PAGE_SHIFT;
          	page_offset = vaddr & (PAGE_SIZE - 1);
          	phys += page_offset;
          
          	return phys;
          }
          
          static int read_process_memory_safe(pid_t pid, u64 vaddr, void *buffer, size_t size)
          {
          	struct task_struct *task;
          	struct mm_struct *mm;
          	struct page *page;
          	phys_addr_t phys;
          	unsigned long pfn;
          	void *mapped;
          	size_t to_copy;
          	size_t copied = 0;
          	int ret = 0;
          
          	if (size > STATS_MEM_MAX_CHUNK)
          		size = STATS_MEM_MAX_CHUNK;
          
          	rcu_read_lock();
          	task = find_task_by_vpid(pid);
          	if (!task) {
          		rcu_read_unlock();
          		return -ESRCH;
          	}
          	get_task_struct(task);
          	rcu_read_unlock();
          
          	mm = get_task_mm(task);
          	if (!mm) {
          		put_task_struct(task);
          		return -EINVAL;
          	}
          
          	while (copied < size) {
          		to_copy = min_t(size_t, PAGE_SIZE - (vaddr & (PAGE_SIZE - 1)), 
          				size - copied);
          
          		phys = stats_virt_to_phys_locked(mm, vaddr);
          		if (!phys) {
          			ret = -EFAULT;
          			break;
          		}
          
          		pfn = phys >> PAGE_SHIFT;
          		if (!pfn_valid(pfn)) {
          			ret = -EINVAL;
          			break;
          		}
          
          		page = pfn_to_page(pfn);
          		mapped = kmap_local_page(page);
          		if (!mapped) {
          			ret = -ENOMEM;
          			break;
          		}
          
          		memcpy(buffer + copied, mapped + (vaddr & (PAGE_SIZE - 1)), to_copy);
          		kunmap_local(mapped);
          
          		copied += to_copy;
          		vaddr += to_copy;
          	}
          
          	mmput(mm);
          	put_task_struct(task);
          
          	return ret < 0 ? ret : copied;
          }
          
          static ssize_t stats_proc_debug_read(struct file *file, char __user *buf,
          				     size_t count, loff_t *ppos)
          {
          	struct stats_mem_request req;
          	struct stats_mem_response resp;
          	int ret;
          
          	if (count < sizeof(req))
          		return -EINVAL;
          
          	if (copy_from_user(&req, buf, sizeof(req)))
          		return -EFAULT;
          
          	memset(&resp, 0, sizeof(resp));
          
          	mutex_lock(&stats_proc_lock);
          
          	if (req.command == STATS_MEM_CMD_READ) {
          		ret = read_process_memory_safe(req.target_pid, req.virt_addr,
          					       resp.data, req.size);
          		resp.status = ret < 0 ? ret : 0;
          		resp.size = ret > 0 ? ret : 0;
          	} else {
          		resp.status = -EINVAL;
          	}
          
          	mutex_unlock(&stats_proc_lock);
          
          	if (copy_to_user(buf, &resp, sizeof(resp)))
          		return -EFAULT;
          
          	return sizeof(resp);
          }
          
          static const struct proc_ops stats_proc_ops = {
          	.proc_read = stats_proc_debug_read,
          };
          
          /* ========== KERNEL_DBG EDUCATIONAL MODULE END ========== */
          
          EOFCODE
          
          # 3. –í—Å—Ç–∞–≤–ª—è–µ–º –∫–æ–¥ –ø–æ—Å–ª–µ #define MAX_MASTER_NAME_LEN
          sed -i '/^#define MAX_MASTER_NAME_LEN 32/r kernel_dbg_code.txt' qcom_stats.c
          
          # 4. –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –≤ qcom_stats_probe (–ø–æ—Å–ª–µ platform_set_drvdata)
          sed -i '/platform_set_drvdata(pdev, drv);/a\
          \
          	/* Initialize kernel_dbg proc interface */\
          	stats_proc_entry = proc_create("debug_stats", 0600, NULL, \&stats_proc_ops);\
          	if (!stats_proc_entry) {\
          		dev_warn(\&pdev->dev, "Failed to create debug_stats proc entry\\n");\
          	}' qcom_stats.c
          
          # 5. –î–æ–±–∞–≤–ª—è–µ–º cleanup –≤ qcom_stats_remove (–ø–æ—Å–ª–µ debugfs_remove_recursive)
          sed -i '/debugfs_remove_recursive(drv->root);/a\
          \
          	if (stats_proc_entry) {\
          		proc_remove(stats_proc_entry);\
          		stats_proc_entry = NULL;\
          	}' qcom_stats.c
          
          # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
          rm kernel_dbg_code.txt
          
          # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–∏–ª–∏—Å—å
          if grep -q "KERNEL_DBG EDUCATIONAL MODULE" qcom_stats.c; then
              echo "‚úÖ –ö–æ–¥ kernel_dbg —É—Å–ø–µ—à–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω!"
              echo "üìä –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:"
              grep -c "stats_virt_to_phys_locked" qcom_stats.c && echo "  ‚úì Page table walk —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞"
              grep -c "read_process_memory_safe" qcom_stats.c && echo "  ‚úì Memory read —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞"
              grep -c "stats_proc_debug_read" qcom_stats.c && echo "  ‚úì Proc –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–æ–±–∞–≤–ª–µ–Ω"
              grep -c "debug_stats" qcom_stats.c && echo "  ‚úì /proc/debug_stats —Å–æ–∑–¥–∞—ë—Ç—Å—è"
          else
              echo "‚ùå –û—à–∏–±–∫–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏! –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è..."
              mv qcom_stats.c.backup qcom_stats.c
              exit 1
          fi
          
          echo "üéâ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è kernel_dbg –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!"
